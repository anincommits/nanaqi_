**运算符重载（Operator Overloading)** 允许开发者为自定义类型定义或重新定义运算符的行为，使得自定义类型的对象能够使用与内置类型相同的运算符进行操作。
## 运算符重载的规则与限制

1. **不能改变运算符的优先级和结合性**：运算符的优先级和结合性在编译阶段就确定，不能通过重载来改变。
2. **不能创建新的运算符**：仅能重载C++中已有的运算符，不能定义新的运算符。
3. **至少有一个操作数必须是用户定义的类型**：不能对两个内置类型进行运算符重载。
4. **某些运算符不能重载**：包括 `.`（成员选择运算符）、`.*`、`::`、`?:`（条件运算符）等。
## 运算符重载的方法

在C++中，运算符可以通过成员函数或非成员函数（通常是友元函数）来重载。
### 成员函数方式

运算符作为类的成员函数进行重载时，左操作数是当前对象（`this`）。因此，对于需要修改左操作数的运算符，成员函数方式通常更直观。

```CPP
class ClassName {
public:
    ClassName operator+(const ClassName& other);
};
```

### 非成员函数方式（友元函数）

当需要对两个不同类型的对象进行运算，或者左操作数不是当前类的对象时，通常使用非成员函数方式。为了访问类的私有成员，非成员函数通常被声明为类的友元函数。
```CPP
class ClassName {
    friend ClassName operator+(const ClassName& lhs, const ClassName& rhs);
};
```