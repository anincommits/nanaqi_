C++ 引入智能指针的主要目的是为了自动化内存管理，减少手动 *new* 和 *delete* 带来的复杂性和[[指针#手动管理指针可能出现以下问题：|错误]]。
智能指针通过[[RAII|RAII]]，在对象生命周期结束时自动释放资源，从而有效[[智能指针的优势|防止内存泄漏和资源管理错误]]。
## std::unique_ptr
`std::unique_ptr` 是一种独占所有权的智能指针，任何时刻只能有一个 `unique_ptr` 实例拥有对某个对象的所有权。不能被拷贝，只能被移动。
 主要特性：
- **独占所有权**：确保资源在一个所有者下。
- **轻量级**：没有引用计数，开销小。
- **自动释放**：在指针销毁时自动释放资源。
```CPP
    // 创建一个 unique_ptr
    std::unique_ptr<Test> ptr1(new Test(100));

    // 使用 make_unique（C++14 引入）
    auto ptr2 = std::make_unique<Test>(200);

    // 移动 unique_ptr
    std::unique_ptr<Test> ptr3 = std::move(ptr1);

    // 重置 unique_ptr
    ptr2.reset(new Test(300));
    ```
##  std::shared_ptr
`std::shared_ptr` 是一种共享所有权的智能指针，允许多个 `shared_ptr` 实例共享对同一个对象的所有权。通过引用计数机制，管理资源的生命周期。
主要特性：
- **共享所有权**：多个 `shared_ptr` 可以指向同一个对象。
- **引用计数**：跟踪有多少 `shared_ptr` 实例指向同一对象。
- **自动释放**：当引用计数为0时，自动释放资源。

`shared_ptr`背后依赖一个控制块（Control Block），用于存储引用计数和指向实际对象的指针。控制块的主要内容包括：
- **强引用计数（`use_count`）**：表示有多少个 `shared_ptr` 指向对象。
- **弱引用计数（`weak_count`）**：表示有多少个 `weak_ptr` 指向对象（不增加强引用计数）。